{
  "version": 3,
  "sources": ["../src/shape.ts", "../src/recipe.ts", "../src/renderer.ts", "../src/main.ts"],
  "sourcesContent": ["enum CornerType {\r\n    NONE,\r\n    FILLED,\r\n    PIN,\r\n    CRYSTAL,\r\n}\r\n\r\nexport class Shape {\r\n    public readonly value: number;\r\n    constructor(\r\n        value: number\r\n    ) {\r\n        this.value = value >>> 0;\r\n    }\r\n\r\n    public static from(text: string): Shape {\r\n        let result = new Shape(0);\r\n\r\n        let index = 0;\r\n        let odd = true\r\n        for (let i = 0; i < text.length; i++) {\r\n            const c = text[i];\r\n            if (c == ':') {\r\n                continue;\r\n            }\r\n\r\n            odd = !odd;\r\n\r\n            if (!odd) {\r\n                switch (c) {\r\n                    case 'C':\r\n                    case 'R':\r\n                    case 'W':\r\n                    case 'S':\r\n                        result = result.setCornerAt((3 - index % 4) + ((index / 4) >>> 0) * 4, CornerType.FILLED)\r\n                        break;\r\n                    case 'P':\r\n                        result = result.setCornerAt((3 - index % 4) + ((index / 4) >>> 0) * 4, CornerType.PIN)\r\n                        break;\r\n                    case 'c':\r\n                        result = result.setCornerAt((3 - index % 4) + ((index / 4) >>> 0) * 4, CornerType.CRYSTAL)\r\n                        break;\r\n                }\r\n                index++\r\n            }\r\n        }\r\n        return new Shape(result.value >>> 0)\r\n    }\r\n\r\n    get [Symbol.toStringTag]() {\r\n        return \"Shape\";\r\n    }\r\n\r\n    private toFilled(): Shape {\r\n        return new Shape((this.value | (this.value >>> 16)) & 0b1111_1111_1111_1111);\r\n    }\r\n\r\n    public layerCount(): number {\r\n        return 4 - (((Math.clz32(this.toFilled().value) - 16) / 4) >>> 0)\r\n    }\r\n\r\n    public toString() {\r\n        const layers = this.layerCount();\r\n\r\n        let result = ''\r\n\r\n        result += this.cornerString(3)\r\n        result += this.cornerString(2)\r\n        result += this.cornerString(1)\r\n        result += this.cornerString(0)\r\n\r\n        if (layers <= 1) {\r\n            return result\r\n        }\r\n\r\n        result += ':'\r\n        result += this.cornerString(7)\r\n        result += this.cornerString(6)\r\n        result += this.cornerString(5)\r\n        result += this.cornerString(4)\r\n\r\n        if (layers == 2) {\r\n            return result\r\n        }\r\n\r\n        result += ':'\r\n        result += this.cornerString(11)\r\n        result += this.cornerString(10)\r\n        result += this.cornerString(9)\r\n        result += this.cornerString(8)\r\n\r\n        if (layers == 3) {\r\n            return result\r\n        }\r\n\r\n        result += ':'\r\n        result += this.cornerString(15)\r\n        result += this.cornerString(14)\r\n        result += this.cornerString(13)\r\n        result += this.cornerString(12)\r\n\r\n        return result\r\n    }\r\n\r\n\r\n    private cornerString(corner: number): string {\r\n        switch (this.cornerAt(corner)) {\r\n            case CornerType.FILLED:\r\n                return 'Cu';\r\n            case CornerType.PIN:\r\n                return 'P-';\r\n            case CornerType.CRYSTAL:\r\n                return 'cu';\r\n            default:\r\n                return '--';\r\n        }\r\n    }\r\n\r\n    private setCornerAt(index: number, value: CornerType): Shape {\r\n        return new Shape(this.value & ~((0b1 << index) >>> 0) & ~(1 << (index + 16)) | ((value & 1) << index) >>> 0 | ((value & 0b10) << (index + 15)) >>> 0)\r\n    }\r\n\r\n    private cornerAt(index: number): CornerType {\r\n        return ((this.value >>> index) & 1) | ((this.value >>> (index + 15)) & 0b10)\r\n    }\r\n\r\n    public hasCrystalOnTopLayer(): boolean {\r\n        let b = this.toFilled().value;\r\n        b |= (b & 0b0111_0111_0111_0111) << 1;\r\n        b |= (b & 0b0011_0011_0011_0011) << 2;\r\n\r\n        const topLayer = (this.value >>> ((3 - ((Math.clz32(b) - 16) / 4) >>> 0) * 4)) & 0b1111_0000_0000_0000_1111;\r\n        return ((topLayer >>> 16) & topLayer) !== 0;\r\n    }\r\n\r\n    public unstack(): [bottom: Shape, top: Shape] {\r\n        if (this.value == 0) {\r\n            return [new Shape(0), new Shape(0)]\r\n        }\r\n        const mask = (0b1111_0000_0000_0000_1111 << ((this.layerCount() - 1) * 4)) >>> 0\r\n        return [new Shape(this.value & ~mask), new Shape(this.value & mask)]\r\n    }\r\n\r\n    public removeBottomEmpty(): Shape {\r\n        if (this.value == 0) {\r\n            return new Shape(0);\r\n        }\r\n\r\n        const mask = 0b1111_0000_0000_0000_1111;\r\n        let value = this.value;\r\n        while (value !== 0 && (value & mask) === 0) {\r\n            value >>>= 4;\r\n        }\r\n\r\n        return new Shape(value);\r\n    }\r\n\r\n    /** If called without proper checking this will result in an invalid shape */\r\n    public unsafeRight(): Shape {\r\n        return new Shape(this.value & 0b0011_0011_0011_0011_0011_0011_0011_0011)\r\n    }\r\n\r\n    /** If called without proper checking this will result in an invalid shape */\r\n    public unsafeLeft(): Shape {\r\n        return new Shape(this.value & ~0b0011_0011_0011_0011_0011_0011_0011_0011)\r\n    }\r\n\r\n    /** If called without proper checking this will result in an invalid shape */\r\n    public unsafeUp(): Shape {\r\n        return new Shape(this.value & 0b1001_1001_1001_1001_1001_1001_1001_1001)\r\n    }\r\n    /** If called without proper checking this will result in an invalid shape */\r\n    public unsafeDown(): Shape {\r\n        return new Shape(this.value & ~0b1001_1001_1001_1001_1001_1001_1001_1001)\r\n    }\r\n\r\n    public isLeftRightValid(): boolean {\r\n        const right = this.unsafeRight()\r\n        const left = this.unsafeLeft()\r\n        return left.collapse().value == left.value && right.collapse().value == right.value\r\n    }\r\n\r\n    public isUpDownValid(): boolean {\r\n        const up = this.unsafeUp()\r\n        const down = this.unsafeDown()\r\n        return up.collapse().value == up.value && down.collapse().value == down.value\r\n    }\r\n\r\n    public rotate90(): Shape {\r\n        return new Shape(((this.value & 0b1110_1110_1110_1110_1110_1110_1110_1110) >>> 1) | ((this.value & 0b0001_0001_0001_0001_0001_0001_0001_0001) << 3))\r\n    }\r\n\r\n    public rotate180(): Shape {\r\n        return this.rotate90().rotate90();\r\n    }\r\n\r\n    public rotate270(): Shape {\r\n        return this.rotate180().rotate90();\r\n    }\r\n\r\n    private collapse(): Shape {\r\n        const sup = this.supported()\r\n        if (sup.value == this.value) {\r\n            return this;\r\n        }\r\n\r\n        let unsupported = this.value & ~sup;\r\n        const crystals = unsupported & (unsupported >>> 16)\r\n        unsupported &= (~(crystals | (crystals << 16))) >>> 0\r\n\r\n        let result = sup;\r\n\r\n        while (unsupported != 0) {\r\n            const group = new Shape(unsupported).firstGroup()\r\n            unsupported = unsupported & ~group.value\r\n\r\n            let valid = 3;\r\n            for (let i = 0; i < 4; i++) {\r\n                if (((group.toFilled().value >>> (i * 4)) & result.toFilled().value) != 0 || ((group.value >>> (i * 4) << (i * 4)) >>> 0) != group.value) {\r\n                    valid = i - 1\r\n                    break\r\n                }\r\n            }\r\n\r\n            result = new Shape(result.value | ((group.value & 0b1111_1111_1111_1111) >>> (valid * 4))\r\n                | ((group.value >>> (valid * 4)) & ~0b1111_1111_1111_1111));\r\n        }\r\n\r\n        return result\r\n    }\r\n\r\n    private supported(): Shape {\r\n        let sup = new Shape(0)\r\n        let newSupported = new Shape(this.value & 0b1111_0000_0000_0000_1111);\r\n\r\n        while (newSupported.value !== sup.value) {\r\n            sup = newSupported\r\n            for (let i = 0; i < 16; i++) {\r\n                if (this.isSupported(this, i, sup)) {\r\n                    newSupported = newSupported.setCornerAt(i, this.cornerAt(i))\r\n                }\r\n            }\r\n        }\r\n\r\n        return sup\r\n    }\r\n    private isSupported(s: Shape, position: number, sup: Shape): boolean {\r\n        if (s.cornerAt(position) === 0b00) {\r\n            return false\r\n        }\r\n\r\n        if (((position / 4) >>> 0) == 0) {\r\n            return true\r\n        }\r\n\r\n        if (sup.cornerAt(position) !== 0b00) {\r\n            return true\r\n        }\r\n\r\n        if (sup.cornerAt(this.below(position)) != 0b00) {\r\n            return true\r\n        }\r\n\r\n        if (s.cornerAt(position) != 0b10 && s.cornerAt(this.rotatePosition(position)) != 0b10 && sup.cornerAt(this.rotatePosition(position)) != 0b00) {\r\n            return true\r\n        }\r\n\r\n        if (s.cornerAt(position) != 0b10 && s.cornerAt(this.rotatePosition(this.rotatePosition(this.rotatePosition(position)))) != 0b10 && sup.cornerAt(this.rotatePosition(this.rotatePosition(this.rotatePosition(position)))) != 0b00) {\r\n            return true\r\n        }\r\n\r\n        if (s.cornerAt(position) == 0b11 && sup.cornerAt(this.above(position)) == 0b11) {\r\n            return true\r\n        }\r\n\r\n        return false\r\n    }\r\n    private rotatePosition(p: number): number {\r\n        return (p + 1) % 4 + ((p / 4) >>> 0) * 4\r\n    }\r\n    private below(p: number): number {\r\n        if (p < 4) {\r\n            return p\r\n        }\r\n        return p - 4\r\n    }\r\n    private above(p: number): number {\r\n        if (p >= 3 * 4) {\r\n            return p\r\n        }\r\n        return p + 4\r\n    }\r\n\r\n    private firstGroup(): Shape {\r\n        for (let i = 0; i < 16; i++) {\r\n            if (this.cornerAt(i) != 0b00) {\r\n                const group = this.connectedGroup(i, new Shape(0));\r\n\r\n                const groupFilled = group.toFilled().value;\r\n                const leftOver = this.toFilled().value & ~groupFilled;\r\n\r\n                if (((groupFilled >>> 4) & leftOver) == 0 && ((groupFilled >>> 8) & leftOver) == 0 && ((groupFilled >>> 12) & leftOver) == 0) {\r\n                    return group\r\n                }\r\n            }\r\n        }\r\n        return new Shape(0);\r\n    }\r\n\r\n    private connectedGroup(position: number, group: Shape): Shape {\r\n        if (this.cornerAt(position) == 0b00) {\r\n            return group\r\n        }\r\n\r\n        if (group.cornerAt(position) == 0b01 || group.cornerAt(position) == 0b11) {\r\n            return group\r\n        }\r\n\r\n        if (this.cornerAt(position) == 0b10) {\r\n            return group.setCornerAt(position, 0b10)\r\n        }\r\n\r\n        group = group.setCornerAt(position, this.cornerAt(position))\r\n\r\n        if (this.cornerAt(this.rotatePosition(position)) == 0b01) {\r\n            group = this.connectedGroup(this.rotatePosition(position), group)\r\n        }\r\n        if (this.cornerAt(this.rotatePosition(this.rotatePosition(this.rotatePosition(position)))) == 0b01) {\r\n            group = this.connectedGroup(this.rotatePosition(this.rotatePosition(this.rotatePosition(position))), group)\r\n        }\r\n        return group\r\n    }\r\n\r\n\r\n    public mirror(): Shape {\r\n        const mask1 = 0x1111_1111\r\n        const mask2 = 0x8888_8888\r\n        const mask3 = mask1 | mask2\r\n\r\n        const mask4 = 0x2222_2222\r\n        const mask5 = 0x4444_4444\r\n        const mask6 = mask4 | mask5\r\n\r\n        let s = this.value\r\n        s = (s & ~mask3) | ((s & mask1) << 3) | ((s & mask2) >>> 3)\r\n        s = (s & ~mask6) | ((s & mask4) << 1) | ((s & mask5) >>> 1)\r\n        return new Shape(s);\r\n    }\r\n\r\n    public isMinimal(): boolean {\r\n        const s = this.value;\r\n        return s === Math.min(\r\n            s,\r\n            this.rotate90().value,\r\n            this.rotate180().value,\r\n            this.rotate270().value,\r\n            this.mirror().value,\r\n            this.mirror().rotate90().value,\r\n            this.mirror().rotate180().value,\r\n            this.mirror().rotate270().value,\r\n        );\r\n    }\r\n\r\n    public unstackWithoutCrystals(): [bottom: Shape, top: Shape] {\r\n        let [bottom, top] = this.unstack();\r\n        const bottomWithCrystals = new Shape(bottom.value | top.crystals().value);\r\n        const topWithoutCrystals = new Shape(top.value & ~top.crystals().value);\r\n        return [bottomWithCrystals, topWithoutCrystals];\r\n    }\r\n\r\n    private crystals(): Shape {\r\n        let s = this.value;\r\n        s = s & (s >>> 16)\r\n        return new Shape(s | (s << 16));\r\n    }\r\n\r\n}", "import { Shape } from \"./shape\";\r\n\r\nconst hardcodedPins = fetch('./hardcoded-pins.json').then(r => r.json());\r\nconst hardcodedStacks = fetch('./hardcoded-stacks.json').then(r => r.json());\r\nconst hardcodedRecipes = fetch('./hardcoded-halfs.json')\r\n    .then(r => r.json())\r\n    .then((recipes: Record<string, {\r\n        operation: string,\r\n        original1: number,\r\n        original2: number,\r\n    }>) =>\r\n        Object.fromEntries(Object.entries(recipes)\r\n            .map(([shape, recipe]) => [shape, { shape: +shape, ...recipe }]))\r\n    );\r\n\r\nexport class Recipe {\r\n\r\n    private constructor(\r\n        public readonly shape: Shape,\r\n        public readonly operation: string,\r\n        public readonly original1: Shape = new Shape(0),\r\n        public readonly original2: Shape = new Shape(0),\r\n    ) { }\r\n\r\n    public static async from(s: Shape): Promise<Recipe> {\r\n        if (s.layerCount() <= 1) {\r\n            return new Recipe(s, \"trivial\")\r\n        }\r\n\r\n        const hardCoded = (await hardcodedRecipes)[s.value];\r\n        if (hardCoded) {\r\n            return new Recipe(s, hardCoded.operation, new Shape(hardCoded.original1 ?? 0), new Shape(hardCoded.original2 ?? 0))\r\n        }\r\n\r\n        const pin = (await hardcodedPins)[s.value];\r\n        if (pin) {\r\n            return new Recipe(s, \"pushPins\", new Shape(pin));\r\n        }\r\n\r\n        const stack = (await hardcodedStacks)[s.value];\r\n        if (stack) {\r\n            return new Recipe(s, \"stack\", new Shape(stack), new Shape(s.value & ~stack).removeBottomEmpty());\r\n        }\r\n\r\n        if (!s.hasCrystalOnTopLayer()) {\r\n            const [bottom, top] = s.unstack()\r\n            return new Recipe(s, \"stack\", bottom, top.removeBottomEmpty());\r\n        }\r\n\r\n        // if (s.unsafeLeft().layerCount() == 0) {\r\n        //     throw new Error(\"This should not happen\");\r\n        //     return new Recipe(s, \"half\");\r\n        // }\r\n\r\n        if (s.isLeftRightValid()) {\r\n            return new Recipe(s, \"combine\", s.unsafeLeft(), s.unsafeRight());\r\n        }\r\n\r\n        if (s.isUpDownValid()) {\r\n            //rotate then do combine via isLeftRightValid\r\n            return new Recipe(s, \"rotate\", s.rotate270());\r\n        }\r\n\r\n        if (!s.isMinimal()) {\r\n            if (s.rotate90().isMinimal() || s.rotate180().isMinimal() || s.rotate270().isMinimal()) {\r\n                return new Recipe(s, \"rotate\", s.rotate270());\r\n            } else {\r\n                return new Recipe(s, \"mirror\", s.mirror());\r\n            }\r\n        }\r\n\r\n        const [bottom, top] = s.unstackWithoutCrystals();\r\n        return new Recipe(s, \"stack\", bottom, top);\r\n    }\r\n}", "import { Shape } from \"./shape\";\r\n\r\nexport function render(shape: Shape, target: HTMLElement) {\r\n    target.innerHTML = `<path fill=\"#f00\" stroke=\"#000\" stroke-width=\"3\" d=\"M 50 50 L 50 25 L 0 0 L 25 50 Z\" />`\r\n}\r\n\r\n//C `<path fill=\"#f00\" stroke=\"#000\" stroke-width=\"3\" d=\"M 50 50 L 0 50 a 50 50 90 0 1 50 -50 Z\" />`\r\n//S `<path fill=\"#f00\" stroke=\"#000\" stroke-width=\"3\" d=\"M 50 50 L 50 25 L 0 0 L 25 50 Z\" />`\r\n//R `<path fill=\"#f00\" stroke=\"#000\" stroke-width=\"3\" d=\"M 50 50 L 0 50 L 0 0 L 50 0 Z\" />`\r\n//W `<path fill=\"#f00\" stroke=\"#000\" stroke-width=\"3\" d=\"M 50 50 L 0 50 a 50 50 90 0 1 50 50 Z\" />`", "import { Recipe } from \"./recipe\";\r\nimport { render } from \"./renderer\";\r\nimport { Shape } from \"./shape\";\r\n\r\nasync function main() {\r\n    Object.assign(globalThis, { solve });\r\n\r\n    solve('----CuCu:----Cu--:----P-cr:----Cucr')\r\n\r\n\r\n    // printRecipe(parseShape('----CuCu:----Cu--:----P-cr:----Cucr'), 0)\r\n    // console.log(printRecipe(mirror(parseShape('----CuCu:----Cu--:----P-cr:----Cucr')), 0))\r\n}\r\n\r\nif (location.hostname == 'localhost') {\r\n    new EventSource('/esbuild').onmessage = () => location.reload()\r\n}\r\n\r\nmain()\r\nasync function solve(shape: string) {\r\n    async function printRecipe(shape: Shape, level: number, mirrored = false): Promise<string> {\r\n        let result = '';\r\n        const recipe = await Recipe.from(shape);\r\n        if (recipe.operation == 'mirror') {\r\n            return printRecipe(shape.mirror(), level, !mirrored)\r\n        }\r\n\r\n        const operation = mirrored && recipe.operation == 'right' ? 'left' : recipe.operation;\r\n\r\n        function printShape(s: Shape) {\r\n            return (mirrored ? s.mirror() : s).toString();\r\n        }\r\n\r\n        if (recipe.original1 && recipe.original2) {\r\n            result += ('&nbsp;&nbsp;&nbsp;&nbsp;'.repeat(level) + printShape(shape) + ' = <span style=\"color:blue\">' + operation + '</span> <span style=\"color:magenta\">' + printShape(recipe.original1) + '</span> + </span> <span style=\"color:red\">' + printShape(recipe.original2)) + '</span><br />';\r\n\r\n            if (recipe.original1.layerCount() > 1 && recipe.original2.layerCount() > 1) {\r\n                level++\r\n            }\r\n\r\n            if (recipe.original1.layerCount() > 1) {\r\n                result += await printRecipe(recipe.original1, level)\r\n            }\r\n            if (recipe.original2.layerCount() > 1) {\r\n                result += await printRecipe(recipe.original2, level)\r\n            }\r\n        } else if (recipe.original1) {\r\n            result += ('&nbsp;&nbsp;&nbsp;&nbsp;'.repeat(level) + printShape(shape) + ' = <span style=\"color:blue\">' + operation + '</span> <span style=\"color:magenta\">' + printShape(recipe.original1)) + '</span><br />';\r\n            if (recipe.original1.layerCount() > 1) {\r\n                result += await printRecipe(recipe.original1, level)\r\n            }\r\n        } else {\r\n            result += ('&nbsp;&nbsp;&nbsp;&nbsp;'.repeat(level) + printShape(shape) + ' = <span style=\"color:blue\">' + operation) + '</span><br />';\r\n        }\r\n\r\n        return result\r\n    }\r\n\r\n\r\n\r\n    const output = document.getElementById('output') as HTMLDivElement;\r\n    output.innerHTML = await printRecipe(Shape.from(shape), 0);\r\n\r\n    render(Shape.from(shape), document.getElementById('svg') as HTMLElement)\r\n};\r\nasync function load(file: string): Promise<any> {\r\n    if ('process' in globalThis) {\r\n        const fs = globalThis['require']('node:fs') as typeof import('fs');\r\n        return new Promise((resolve, reject) => {\r\n            fs.readFile(file, (err, data) => {\r\n                if (err) {\r\n                    reject(err)\r\n                } else {\r\n                    resolve(JSON.parse(data as unknown as string))\r\n                }\r\n            })\r\n        })\r\n    }\r\n\r\n    return fetch(file).then(r => r.json())\r\n}\r\n\r\nasync function readSection(file: string, start: number, end: number): Promise<Uint8Array> {\r\n    const fs = globalThis['require']('node:fs') as typeof import('fs');\r\n    return new Promise<Uint8Array>((resolve, reject) => {\r\n        const buffer = new Uint8Array(end - start)\r\n        const fileStream = fs.createReadStream(file, { start, end: end - 1 });\r\n        let offset = 0;\r\n        fileStream.on('data', (chunk: Buffer) => {\r\n            buffer.set(chunk, offset);\r\n            offset += chunk.length;\r\n        });\r\n        fileStream.on('end', () => {\r\n            if (offset != buffer.length) {\r\n                const newBuffer = new Uint8Array(offset);\r\n                newBuffer.set(buffer.slice(0, offset));\r\n                resolve(newBuffer)\r\n            } else {\r\n                resolve(buffer)\r\n            }\r\n        });\r\n        fileStream.on('error', (err) => {\r\n            reject(err)\r\n        });\r\n    });\r\n}\r\n"],
  "mappings": "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",
  "names": ["Shape", "_Shape", "value", "text", "result", "index", "odd", "i", "c", "layers", "corner", "b", "topLayer", "mask", "right", "left", "up", "down", "sup", "unsupported", "crystals", "group", "valid", "newSupported", "s", "position", "p", "groupFilled", "leftOver", "bottom", "top", "bottomWithCrystals", "topWithoutCrystals", "hardcodedPins", "hardcodedStacks", "hardcodedRecipes", "recipes", "shape", "recipe", "Recipe", "_Recipe", "operation", "original1", "Shape", "original2", "s", "hardCoded", "pin", "stack", "bottom", "top", "render", "shape", "target", "main", "solve", "shape", "printRecipe", "level", "mirrored", "result", "recipe", "Recipe", "operation", "printShape", "s", "output", "Shape", "render"]
}
